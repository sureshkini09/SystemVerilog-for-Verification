# Linear Feedback Shift Register (LFSR)

## Introduction
A **Linear Feedback Shift Register (LFSR)** is a shift register that generates pseudo-random sequences using linear feedback logic. LFSRs are widely used in cryptography, error detection, random number generation, and Built-in Self-Test (BIST) in hardware verification.

## How LFSR Works
An LFSR consists of:
- A **shift register** (A series of flip-flops connected in sequence)
- A **feedback function**, typically implemented using XOR or XNOR gates
- The feedback bit is shifted into the register while the least significant bit (LSB) is discarded.

The sequence generated by an LFSR is deterministic but appears random, with a period that depends on the polynomial used for feedback.

## Properties of LFSR
âœ… **Pseudo-Random Output** â€“ Generates a sequence that appears random but is deterministic.  
âœ… **Periodicity** â€“ The sequence repeats after a certain number of cycles.  
âœ… **Used in BIST** â€“ Common in Design-for-Testability (DFT) applications.  
âœ… **Efficient Implementation** â€“ Requires fewer logic gates than true random number generators.  

## LFSR Feedback Polynomials
The choice of the feedback polynomial determines the sequence length. A maximum-length LFSR of `n` bits can generate `(2^n - 1)` unique states before repeating.

### Example Feedback Polynomials:
| LFSR Size | Polynomial (Taps) |
|-----------|------------------|
| 3-bit     | x^3 + x^2 + 1   |
| 4-bit     | x^4 + x^3 + 1   |
| 8-bit     | x^8 + x^6 + x^5 + x^4 + 1 |
| 16-bit    | x^16 + x^14 + x^13 + x^11 + 1 |

## Example: 4-bit LFSR (XOR at Tap Positions 3 and 4)
Starting with the seed `1001`:

| Step | Output | Feedback (XOR) | Next State |
|------|--------|---------------|------------|
| 1    | 1001   | 1 âŠ• 0 = 1      | 1100       |
| 2    | 1100   | 1 âŠ• 0 = 1      | 1110       |
| 3    | 1110   | 1 âŠ• 1 = 0      | 0111       |
| ...  | ...    | ...           | ...        |

## Verilog Implementation of LFSR
### 4-bit LFSR with XOR Feedback
```verilog
module lfsr_4bit (
    input clk, reset,
    output reg [3:0] lfsr_out
);
    always @(posedge clk or posedge reset) begin
        if (reset)
            lfsr_out <= 4'b1001; // Initial seed value
        else
            lfsr_out <= {lfsr_out[2:0], lfsr_out[3] ^ lfsr_out[2]};
    end
endmodule
```

```verilog
 module lsfr_tb ();

  // Write your Testbench here...
	logic clk;
  logic reset;
  logic lfsr_o;
  
  lsfr_4bit dut (.*);
  
  always #10 clk = ~clk;

  initial begin
    clk <= 1'b0;
    reset <= 1'b0;
    repeat (5) @(posedge  clk);
    reset = 1'b1;
    
    for(int i=0;i<127;i=i+1) 
      @(posedge clk);
    $finish();
  end
    
endmodule
```


### Explanation
- **clk**: Clock input to drive the shift operation.
- **reset**: Resets the LFSR to an initial state (`1001`).
- **lfsr_out**: 4-bit output that holds the pseudo-random sequence.
- The feedback is generated using XOR between bit positions 3 and 2 (`lfsr_out[3] âŠ• lfsr_out[2]`).

## Advanced LFSR Concepts

### Galois LFSR
A Galois LFSR is an alternative implementation where feedback is applied at each stage instead of shifting all bits at once.

```verilog
module galois_lfsr_4bit (
    input clk, reset,
    output reg [3:0] lfsr_out
);
    always @(posedge clk or posedge reset) begin
        if (reset)
            lfsr_out <= 4'b1001;
        else begin
            lfsr_out[3] <= lfsr_out[2];
            lfsr_out[2] <= lfsr_out[1];
            lfsr_out[1] <= lfsr_out[0];
            lfsr_out[0] <= lfsr_out[3] ^ lfsr_out[2];
        end
    end
endmodule
```

### Differences Between Fibonacci and Galois LFSR
| Feature          | Fibonacci LFSR | Galois LFSR |
|-----------------|---------------|-------------|
| Feedback Applied | XORed at LSB   | XORed at multiple stages |
| Performance     | Slower         | Faster |
| Area Overhead  | More           | Less |

## Applications of LFSR
- **Cryptography** (Stream ciphers)
- **Error Detection** (CRC generation)
- **Built-in Self-Test (BIST)** (Used in DFT for fault testing)
- **Random Number Generation**
- **Spread Spectrum Communication**

## Conclusion
LFSRs are powerful pseudo-random sequence generators with wide applications in digital design. They are highly efficient and widely used in areas such as cryptography, test pattern generation, and communication systems.

By selecting an appropriate feedback polynomial, an LFSR can achieve a maximum-length sequence, ensuring optimal performance.

---
For further study, try implementing an LFSR with different polynomial taps and compare the generated sequences! ðŸš€
